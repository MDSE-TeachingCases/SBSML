/*
 * generated by Xtext 2.22.0
 */
package at.ac.tuwien.big.serializer;

import at.ac.tuwien.big.services.SbsmlGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import sbsml.Actuator;
import sbsml.Argument;
import sbsml.BoolThreshold;
import sbsml.Configuration;
import sbsml.Connection;
import sbsml.Controller;
import sbsml.FloatThreshold;
import sbsml.FogDevice;
import sbsml.IntThreshold;
import sbsml.Node;
import sbsml.Port;
import sbsml.SbsmlPackage;
import sbsml.Sensor;
import sbsml.Service;
import sbsml.ServiceCall;
import sbsml.SmartSystem;
import sbsml.Unit;

@SuppressWarnings("all")
public class SbsmlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SbsmlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SbsmlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SbsmlPackage.ACTUATOR:
				sequence_Actuator(context, (Actuator) semanticObject); 
				return; 
			case SbsmlPackage.ARGUMENT:
				sequence_Argument(context, (Argument) semanticObject); 
				return; 
			case SbsmlPackage.BOOL_THRESHOLD:
				sequence_BoolThreshold(context, (BoolThreshold) semanticObject); 
				return; 
			case SbsmlPackage.CONFIGURATION:
				sequence_Config(context, (Configuration) semanticObject); 
				return; 
			case SbsmlPackage.CONNECTION:
				sequence_Connection(context, (Connection) semanticObject); 
				return; 
			case SbsmlPackage.CONTROLLER:
				sequence_Controller(context, (Controller) semanticObject); 
				return; 
			case SbsmlPackage.FLOAT_THRESHOLD:
				sequence_FloatThreshold(context, (FloatThreshold) semanticObject); 
				return; 
			case SbsmlPackage.FOG_DEVICE:
				sequence_FogDevice(context, (FogDevice) semanticObject); 
				return; 
			case SbsmlPackage.INT_THRESHOLD:
				sequence_IntThreshold(context, (IntThreshold) semanticObject); 
				return; 
			case SbsmlPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case SbsmlPackage.PARAMETER:
				if (rule == grammarAccess.getParameterRule()) {
					sequence_Parameter(context, (sbsml.Parameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSensorParamRule()) {
					sequence_SensorParam(context, (sbsml.Parameter) semanticObject); 
					return; 
				}
				else break;
			case SbsmlPackage.PORT:
				sequence_Port(context, (Port) semanticObject); 
				return; 
			case SbsmlPackage.SENSOR:
				sequence_Sensor(context, (Sensor) semanticObject); 
				return; 
			case SbsmlPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case SbsmlPackage.SERVICE_CALL:
				sequence_ServiceCall(context, (ServiceCall) semanticObject); 
				return; 
			case SbsmlPackage.SMART_SYSTEM:
				sequence_SmartSystem(context, (SmartSystem) semanticObject); 
				return; 
			case SbsmlPackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Thing returns Actuator
	 *     Actuator returns Actuator
	 *
	 * Constraint:
	 *     (name=ID shortName=ID ports+=Port* services+=Service*)
	 */
	protected void sequence_Actuator(ISerializationContext context, Actuator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns Argument
	 *
	 * Constraint:
	 *     stringValue=Arg
	 */
	protected void sequence_Argument(ISerializationContext context, Argument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.ARGUMENT__STRING_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.ARGUMENT__STRING_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArgumentAccess().getStringValueArgParserRuleCall_0(), semanticObject.getStringValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Threshold returns BoolThreshold
	 *     BoolThreshold returns BoolThreshold
	 *
	 * Constraint:
	 *     (source=[Node|ID] parameter=[Parameter|ID] triggerOn=BOOL)
	 */
	protected void sequence_BoolThreshold(ISerializationContext context, BoolThreshold semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.THRESHOLD__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.THRESHOLD__SOURCE));
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.THRESHOLD__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.THRESHOLD__PARAMETER));
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.BOOL_THRESHOLD__TRIGGER_ON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.BOOL_THRESHOLD__TRIGGER_ON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolThresholdAccess().getSourceNodeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(SbsmlPackage.Literals.THRESHOLD__SOURCE, false));
		feeder.accept(grammarAccess.getBoolThresholdAccess().getParameterParameterIDTerminalRuleCall_4_0_1(), semanticObject.eGet(SbsmlPackage.Literals.THRESHOLD__PARAMETER, false));
		feeder.accept(grammarAccess.getBoolThresholdAccess().getTriggerOnBOOLTerminalRuleCall_6_0(), semanticObject.isTriggerOn());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Config returns Configuration
	 *
	 * Constraint:
	 *     (name=ID nodes+=Node* (connections+=Connection connections+=Connection*)? controllers+=Controller*)
	 */
	protected void sequence_Config(ISerializationContext context, Configuration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Connection returns Connection
	 *
	 * Constraint:
	 *     (nodeA=[Node|ID] portA=[Port|ID] nodeB=[Node|ID] portB=[Port|ID])
	 */
	protected void sequence_Connection(ISerializationContext context, Connection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.CONNECTION__NODE_A) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.CONNECTION__NODE_A));
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.CONNECTION__PORT_A) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.CONNECTION__PORT_A));
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.CONNECTION__NODE_B) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.CONNECTION__NODE_B));
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.CONNECTION__PORT_B) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.CONNECTION__PORT_B));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConnectionAccess().getNodeANodeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(SbsmlPackage.Literals.CONNECTION__NODE_A, false));
		feeder.accept(grammarAccess.getConnectionAccess().getPortAPortIDTerminalRuleCall_2_0_1(), semanticObject.eGet(SbsmlPackage.Literals.CONNECTION__PORT_A, false));
		feeder.accept(grammarAccess.getConnectionAccess().getNodeBNodeIDTerminalRuleCall_4_0_1(), semanticObject.eGet(SbsmlPackage.Literals.CONNECTION__NODE_B, false));
		feeder.accept(grammarAccess.getConnectionAccess().getPortBPortIDTerminalRuleCall_6_0_1(), semanticObject.eGet(SbsmlPackage.Literals.CONNECTION__PORT_B, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Controller returns Controller
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         computationNode=[Node|ID] 
	 *         mips=ELong 
	 *         threshold+=Threshold 
	 *         threshold+=Threshold* 
	 *         servicecalls+=ServiceCall*
	 *     )
	 */
	protected void sequence_Controller(ISerializationContext context, Controller semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Threshold returns FloatThreshold
	 *     FloatThreshold returns FloatThreshold
	 *
	 * Constraint:
	 *     (source=[Node|ID] parameter=[Parameter|ID] comperator=Comparator value=FLOAT)
	 */
	protected void sequence_FloatThreshold(ISerializationContext context, FloatThreshold semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.THRESHOLD__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.THRESHOLD__SOURCE));
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.THRESHOLD__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.THRESHOLD__PARAMETER));
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.FLOAT_THRESHOLD__COMPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.FLOAT_THRESHOLD__COMPERATOR));
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.FLOAT_THRESHOLD__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.FLOAT_THRESHOLD__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloatThresholdAccess().getSourceNodeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(SbsmlPackage.Literals.THRESHOLD__SOURCE, false));
		feeder.accept(grammarAccess.getFloatThresholdAccess().getParameterParameterIDTerminalRuleCall_4_0_1(), semanticObject.eGet(SbsmlPackage.Literals.THRESHOLD__PARAMETER, false));
		feeder.accept(grammarAccess.getFloatThresholdAccess().getComperatorComparatorEnumRuleCall_5_0(), semanticObject.getComperator());
		feeder.accept(grammarAccess.getFloatThresholdAccess().getValueFLOATTerminalRuleCall_6_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Thing returns FogDevice
	 *     FogDevice returns FogDevice
	 *
	 * Constraint:
	 *     (name=ID shortName=ID ports+=Port* mips=ELong)
	 */
	protected void sequence_FogDevice(ISerializationContext context, FogDevice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Threshold returns IntThreshold
	 *     IntThreshold returns IntThreshold
	 *
	 * Constraint:
	 *     (source=[Node|ID] parameter=[Parameter|ID] comperator=Comparator value=INT)
	 */
	protected void sequence_IntThreshold(ISerializationContext context, IntThreshold semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.THRESHOLD__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.THRESHOLD__SOURCE));
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.THRESHOLD__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.THRESHOLD__PARAMETER));
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.INT_THRESHOLD__COMPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.INT_THRESHOLD__COMPERATOR));
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.INT_THRESHOLD__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.INT_THRESHOLD__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntThresholdAccess().getSourceNodeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(SbsmlPackage.Literals.THRESHOLD__SOURCE, false));
		feeder.accept(grammarAccess.getIntThresholdAccess().getParameterParameterIDTerminalRuleCall_4_0_1(), semanticObject.eGet(SbsmlPackage.Literals.THRESHOLD__PARAMETER, false));
		feeder.accept(grammarAccess.getIntThresholdAccess().getComperatorComparatorEnumRuleCall_5_0(), semanticObject.getComperator());
		feeder.accept(grammarAccess.getIntThresholdAccess().getValueINTTerminalRuleCall_6_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Node
	 *
	 * Constraint:
	 *     (name=ID thing=[Thing|ID])
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.NODE__THING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.NODE__THING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNodeAccess().getThingThingIDTerminalRuleCall_3_0_1(), semanticObject.eGet(SbsmlPackage.Literals.NODE__THING, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=ID unit=[Unit|ID])
	 */
	protected void sequence_Parameter(ISerializationContext context, sbsml.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.PARAMETER__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.PARAMETER__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getUnitUnitIDTerminalRuleCall_2_0_1(), semanticObject.eGet(SbsmlPackage.Literals.PARAMETER__UNIT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Port returns Port
	 *
	 * Constraint:
	 *     (singleConnection?='single'? name=ID)
	 */
	protected void sequence_Port(ISerializationContext context, Port semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SensorParam returns Parameter
	 *
	 * Constraint:
	 *     (name=ID unit=[Unit|ID])
	 */
	protected void sequence_SensorParam(ISerializationContext context, sbsml.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, SbsmlPackage.Literals.PARAMETER__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SbsmlPackage.Literals.PARAMETER__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSensorParamAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSensorParamAccess().getUnitUnitIDTerminalRuleCall_3_0_1(), semanticObject.eGet(SbsmlPackage.Literals.PARAMETER__UNIT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Thing returns Sensor
	 *     Sensor returns Sensor
	 *
	 * Constraint:
	 *     (name=ID shortName=ID ports+=Port* parameters+=SensorParam*)
	 */
	protected void sequence_Sensor(ISerializationContext context, Sensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ServiceCall returns ServiceCall
	 *
	 * Constraint:
	 *     (node=[Node|ID] service=[Service|ID] (arguments+=Argument arguments+=Argument*)?)
	 */
	protected void sequence_ServiceCall(ISerializationContext context, ServiceCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter*)? description=STRING?)
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SmartSystem returns SmartSystem
	 *
	 * Constraint:
	 *     (name=ID (units+=Unit units+=Unit*)? (things+=Thing | configs+=Config)*)
	 */
	protected void sequence_SmartSystem(ISerializationContext context, SmartSystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (name=ID abbreviation=STRING? type=DataType)
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
